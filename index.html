<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
  </head>
  <body>
    <script>
      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
          default: "arcade",
          arcade: {
            debug: false
          }
        },
        scene: {
          preload: preload,
          create: create,
          update: update
        }
      };

      let pet = null;
      let cursor = null;
      let food = null;
      const game = new Phaser.Game(config);

      const PET_STATES = {
        IDLE: "IDLE",
        MOVING: "MOVING"
      };

      // Asset constants
      const BACKGROUNDS = {
        PINK: "background-pink"
      };

      /**
       * Every time a new sprite sheet is added, its reference key should be added here.
       */
      const SPRITES = {
        PET: {
          ROCK: {
            IDLE: "sprite-rock-idle",
            MOVING: "sprite-rock-moving"
          }
        },
        UI: {
          POINTER: {
            CLICK: "sprite-pointer-click"
          }
        },
        FOOD: {
          BANANAS: "sprite-bananas"
        }
      };

      /**
       * Every time a new animation is added, its reference key should be added here. These
       * rely on associated SPRITE being defined as well!
       */
      const ANIMATIONS = {
        PET: {
          ROCK: {
            IDLE: "animation-rock-idle",
            MOVING: "animation-rock-moving",
            EATING: "sprite-rock-eating"
          }
        },
        UI: {
          POINTER: {
            CLICK: "animation-pointer-click"
          }
        },
        FOOD: {
          BANANAS: "animation-bananas"
        }
      };

      /**
       * Load all assets here:
       * 1) Pet sprite
       */
      function preload() {
        this.load.image(BACKGROUNDS.PINK, "assets/backgrounds/pink.png");
        this.load.spritesheet(
          SPRITES.PET.ROCK.IDLE,
          "assets/pets/rock/idle.png",
          {
            frameWidth: 38,
            frameHeight: 34
          }
        );
        this.load.spritesheet(
          SPRITES.PET.ROCK.MOVING,
          "assets/pets/rock/moving.png",
          {
            frameWidth: 38,
            frameHeight: 34
          }
        );
        this.load.spritesheet(
          SPRITES.UI.POINTER.CLICK,
          "assets/ui/clicked.png",
          {
            frameWidth: 32,
            frameHeight: 32
          }
        );
        this.load.spritesheet(SPRITES.FOOD.BANANAS, "assets/food/bananas.png", {
          frameWidth: 32,
          frameHeight: 32
        });
      }

      /**
       * @function setupPet Initialize and return pet with sprite, physics and collision with world bounds.
       * Starts in the center of the canvas
       */
      const setupPet = (spriteKey, _this) => {
        const newPet = _this.physics.add.sprite(400, 300, spriteKey);
        newPet.setCollideWorldBounds(true);

        return newPet;
      };

      const setupFood = (fruitSpriteKey, _this) => {
        const newFruit = _this.physics.add
          .sprite(200, 300, fruitSpriteKey)
          .setScale(1.25);

        newFruit.anims.play(ANIMATIONS.FOOD.BANANAS, true);

        return newFruit;
      };

      /**
       * @function setupCursor Initialize and return an invisible cursor with sprite, physics and animations. Initially placed in (0, 0) of the canvas.
       */
      const setupCursor = (cursorSprite, _this) => {
        const newCursor = _this.physics.add
          .sprite(0, 0, cursorSprite)
          .setVisible(false);

        newCursor.on("animationcomplete", () => {
          newCursor.setVisible(false);
        });

        return newCursor;
      };

      /**
       * @function setupBackground Build background given background tile sprite key.
       *
       * TODO: Actually build background from tile sprite
       */
      const setupBackground = (backgroundTileSpriteKey, _this) => {
        _this.add.image(400, 300, backgroundTileSpriteKey);
      };

      /**
       * @function defineAnimations Define all animations.
       *
       * Trying to keep things cons
       */
      const defineAnimations = _this => {
        _this.anims.create({
          key: ANIMATIONS.PET.ROCK.IDLE,
          frames: _this.anims.generateFrameNumbers(SPRITES.PET.ROCK.IDLE, {
            start: 0,
            end: 14
          }),
          frameRate: 10,
          repeat: -1
        });
        _this.anims.create({
          key: ANIMATIONS.PET.ROCK.MOVING,
          frames: _this.anims.generateFrameNumbers(SPRITES.PET.ROCK.MOVING, {
            start: 0,
            end: 14
          }),
          frameRate: 10,
          repeat: -1
        });

        _this.anims.create({
          key: ANIMATIONS.PET.ROCK.MOVING,
          frames: _this.anims.generateFrameNumbers(SPRITES.PET.ROCK.MOVING, {
            start: 0,
            end: 14
          }),
          frameRate: 10,
          repeat: -1
        });

        _this.anims.create({
          key: ANIMATIONS.FOOD.BANANAS,
          frames: _this.anims.generateFrameNumbers(SPRITES.FOOD.BANANAS, {
            start: 0,
            end: 14
          }),
          frameRate: 10,
          repeat: -1
        });

        _this.anims.create({
          key: ANIMATIONS.UI.POINTER.CLICK,
          frames: _this.anims.generateFrameNumbers(SPRITES.UI.POINTER.CLICK, {
            start: 0,
            end: 6
          }),
          frameRate: 15
        });
      };

      const setupInputHandlers = _this => {
        // Move to mouse and
        _this.input.on(
          "pointerdown",
          function(pointer) {
            cursor.setActive(true);
            cursor.anims.play(ANIMATIONS.UI.POINTER.CLICK);

            pet.state = PET_STATES.MOVING;
            cursor.setVisible(true).setPosition(pointer.x, pointer.y);

            _this.physics.moveToObject(pet, pointer, 150);
          },
          _this
        );
      };
      /**
       * Create all game objects and their relationships here:
       * 1) Pet
       * 2) Input handling
       */
      function create() {
        setupBackground(BACKGROUNDS.PINK, this);
        defineAnimations(this);

        // The player and its settings
        pet = setupPet(SPRITES.PET.ROCK.IDLE, this);
        food = setupFood(SPRITES.FOOD.BANANAS, this);
        cursor = setupCursor(SPRITES.UI.POINTER.CLICK, this);

        // Collisions
        this.physics.add.overlap(
          pet,
          cursor,
          () => {
            pet.state = PET_STATES.IDLE;
            pet.setVelocity(0);
            cursor.setPosition(0, 0);
          },
          null,
          this
        );

        setupInputHandlers(this);
      }

      /**
       *  Handle all interactions here
       */
      function update() {
        handlePetAnimation(pet);
      }

      /**
       * @function handlePetAnimation Apply pet's animation depending on their state.
       *
       * There should be an animation for each state.
       */
      handlePetAnimation = pet => {
        switch (pet.state) {
          case PET_STATES.MOVING:
            pet.anims.play(ANIMATIONS.PET.ROCK.MOVING, true);
            break;
          default:
            pet.anims.play(ANIMATIONS.PET.ROCK.IDLE, true);
        }
      };
    </script>
  </body>
</html>
