<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
  </head>
  <body>
    <script type="text/javascript" src="./constants.js"></script>
    <script>
      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
          default: "arcade",
          arcade: {
            debug: false
          }
        },
        scene: {
          preload: preload,
          create: create,
          update: update
        }
      };

      // Global variables.
      let pet = null;
      let pointer = null;
      let food = null;
      const game = new Phaser.Game(config);

      /**
       * Load all assets here:
       * 1) Pet sprite
       */
      function preload() {
        this.load.image(BACKGROUNDS.PINK, "assets/backgrounds/pink.png");
        this.load.spritesheet(
          SPRITES.PET.ROCK.IDLE,
          "assets/pets/rock/idle.png",
          {
            frameWidth: 38,
            frameHeight: 34
          }
        );
        this.load.spritesheet(
          SPRITES.PET.ROCK.MOVING,
          "assets/pets/rock/moving.png",
          {
            frameWidth: 38,
            frameHeight: 34
          }
        );
        this.load.spritesheet(
          SPRITES.UI.POINTER.CLICK,
          "assets/ui/clicked.png",
          {
            frameWidth: 32,
            frameHeight: 32
          }
        );
        this.load.spritesheet(SPRITES.FOOD.BANANAS, "assets/food/bananas.png", {
          frameWidth: 32,
          frameHeight: 32
        });
      }

      /**
       * GAME OBJECT CREATORS
       */
      /**
       * @function createPet Instantiate and return Game Object for pet with type, state, animations and their associtated
       * helpers based off of given `petConfigKey`. Placed in the center of the canvas
       *
       * Note to self:
       * My JS chops are not as good as I thought, dealing with `this`, for now `.bind` works.
       */
      const createPet = ({ petConfigKey, _this }) => {
        const petConfig = PET_CONFIGS[petConfigKey];

        const newPet = _this.physics.add.sprite(400, 300, petConfig.sprite);

        // Activate physics with world and interactions with user
        newPet.setCollideWorldBounds(true);
        newPet.setInteractive({ useHandCursor: true });
        _this.input.setDraggable(newPet);

        // Setup all related data to specific pet based on id
        newPet.setData({
          type: GAME_OBJECT_TYPES.PET,
          state: PET_STATES.IDLE,
          animations: petConfig.animations
        });

        newPet.playAnimation = function(animationKey) {
          const animations = this.getData("animations");
          this.anims.play(animations[animationKey]);
        }.bind(newPet);

        newPet.getState = function() {
          return this.getData("state");
        }.bind(newPet);

        newPet.setState = function(newState) {
          this.setData({ state: newState });
        }.bind(newPet);

        newPet.playCurrentStateAnimation = function() {
          this.playAnimation(this.getState());
        }.bind(newPet);

        // Some actions should cause other actions to be ignored. Use this function to determine that!
        newPet.canAct = function() {
          return this.getState() !== PET_STATES.EATING;
        }.bind(newPet);

        return newPet;
      };

      /**
       * LOAD GAME ASSETS, DEFINE ANIMATIONS, SETUP GAME OBJECTS ETC
       */
      const createFood = ({ foodConfigKey, phaser }) => {
        const foodConfig = FOOD_CONFIG[foodConfigKey];
        // Create Game Object and turn on phyics and interactions with user
        const newFood = phaser.physics.add
          .sprite(200, 300, foodConfig.sprite)
          .setScale(1.25); // They are a little small so make them bigger without making them ugly
        newFood.setInteractive({ useHandCursor: true });
        phaser.input.setDraggable(newFood);

        newFood.setData({
          type: GAME_OBJECT_TYPES.FOOD,
          state: FOOD_STATES.DEFAULT,
          animations: foodConfig.animations
        });

        newFood.setState = function(newState) {
          this.setData({ state: newState });
        }.bind(newFood);

        newFood.getState = function() {
          return this.getData("state");
        }.bind(newFood);

        newFood.playAnimation = function(animationKey) {
          const animations = this.getData("animations");

          this.anims.play(animations[animationKey]);
        }.bind(newFood);

        newFood.playCurrentStateAnimation = function() {
          this.playAnimation(this.getData("state"));
        }.bind(newFood);

        return newFood;
      };

      /**
       * @function setupPointer Initialize and return an invisible pointer with sprite, physics and animations. Initially placed in (0, 0) of the canvas.
       */
      const setupPointer = (pointerSprite, _this) => {
        const newPointer = _this.physics.add
          .sprite(0, 0, pointerSprite)
          .setVisible(false);

        newPointer.on("animationcomplete", () => {
          newPointer.setVisible(false);
        });

        return newPointer;
      };

      /**
       * @function setupTileBackground Build background given background tile sprite key.
       *
       * I figure that the create Game Objects don't need to be returned since they'll only be set once.
       */
      const setupTileBackground = (backgroundTileSpriteKey, _this) => {
        const container = _this.add
          .container(400, 300)
          .setName("tile-background-container");
        const tileSprite = _this.add.tileSprite(
          0,
          0,
          800,
          600,
          BACKGROUNDS.PINK
        );

        container.add(tileSprite);
      };

      const setupInputHandlers = _this => {
        moveInGamePointerAndAnimateOnClick(_this);
        movePetToPointerIfIdle(pet, pointer, _this);
      };

      /**
       * @function defineAllAnimations Define all animations.
       *
       * Trying to keep things cons
       */
      const defineAllAnimations = _this => {
        _this.anims.create({
          key: ANIMATIONS.PET.ROCK.IDLE,
          frames: _this.anims.generateFrameNumbers(SPRITES.PET.ROCK.IDLE, {
            start: 0,
            end: 14
          }),
          frameRate: 10,
          repeat: -1
        });
        _this.anims.create({
          key: ANIMATIONS.PET.ROCK.MOVING,
          frames: _this.anims.generateFrameNumbers(SPRITES.PET.ROCK.MOVING, {
            start: 0,
            end: 14
          }),
          frameRate: 10,
          repeat: -1
        });

        _this.anims.create({
          key: ANIMATIONS.PET.ROCK.EATING,
          frames: _this.anims.generateFrameNumbers(SPRITES.PET.ROCK.IDLE, {
            frames: [14, 12, 14, 10]
          }),
          frameRate: 10,
          repeat: -1
        });

        _this.anims.create({
          key: ANIMATIONS.PET.ROCK.EATING,
          frames: _this.anims.generateFrameNumbers(SPRITES.PET.ROCK.IDLE, {
            frames: [14, 13, 12, 11]
          }),
          frameRate: 10,
          repeat: -1
        });

        _this.anims.create({
          key: ANIMATIONS.FOOD.BANANAS.DEFAULT,
          frames: _this.anims.generateFrameNumbers(SPRITES.FOOD.BANANAS, {
            start: 0,
            end: 14
          }),
          frameRate: 10,
          repeat: -1
        });

        _this.anims.create({
          key: ANIMATIONS.UI.POINTER.CLICK,
          frames: _this.anims.generateFrameNumbers(SPRITES.UI.POINTER.CLICK, {
            start: 0,
            end: 6
          }),
          frameRate: 15
        });
      };

      /**
       * MOVING GAME OBJECTS
       */
      const moveInGamePointerAndAnimateOnClick = _this => {
        _this.input.on(
          "pointerdown",
          function(event) {
            pointer.setVisible(true).setPosition(event.x, event.y);
            pointer.anims.play(ANIMATIONS.UI.POINTER.CLICK);
          },
          _this
        );
      };

      const movePetToPointerIfIdle = (petToMove, ObjectToMoveTo, _this) => {
        _this.input.on(
          "pointerdown",
          function(pointer) {
            if (petToMove.canAct()) {
              pet.setState(PET_STATES.MOVING);
              pet.playCurrentStateAnimation();

              _this.physics.moveToObject(petToMove, ObjectToMoveTo, 150);
            }
          },
          _this
        );
      };

      /**
       * OBJECT INTERACTIONS
       */
      const defineObjectInteractions = _this => {
        _this.physics.add.overlap(
          pet,
          pointer,
          () => {
            pet.setState(PET_STATES.IDLE);
            pet.setVelocity(0);
            pet.playCurrentStateAnimation();

            pointer.setPosition(0, 0);
          },
          null,
          _this
        );

        _this.physics.add.overlap(
          pet,
          food,
          () => {
            handleEating(pet, food, _this);
          },
          null,
          _this
        );

        _this.input.on("drag", function(pointer, gameObject, dragX, dragY) {
          console.log(gameObject);
        });
      };

      /**
       * USER FEEDBACK EFFECTS
       * (things that help the user see something is happening)
       */
      /**
       * @function flashingSpriteAnimation Create and apply a flashing silhouette over the object using graphics. Return graphics objects.
       */
      const flashingSpriteAnimation = ({
        objectToAnimate,
        objectSpriteKey,
        colorInHEX,
        _this
      }) => {
        // Create a graphics only copy of the object, with color
        const graphics = _this.add
          .graphics({
            x: objectToAnimate.x - objectToAnimate.width / 2,
            y: objectToAnimate.y - objectToAnimate.height / 2
          })
          .fillStyle(colorInHEX, 0.75)
          .setTexture(objectSpriteKey, undefined, 1)
          .fillRect(0, 0, objectToAnimate.width, objectToAnimate.height);

        // Apply fade-in/out effect on graphics
        _this.tweens.add({
          targets: graphics,
          alpha: 0,
          ease: "Cubic.easeOut",
          duration: 350,
          repeat: -1,
          yoyo: true
        });

        return graphics;
      };

      const handleEating = (petEating, objectBeingEaten, _this) => {
        if (petEating.canAct()) {
          petEating.setVelocity(0);
          petEating.setState(PET_STATES.EATING);
          petEating.playCurrentStateAnimation();

          objectBeingEaten.anims.stop();

          const flashingObjectGraphics = flashingSpriteAnimation({
            objectToAnimate: objectBeingEaten,
            objectSpriteKey: SPRITES.FOOD.BANANAS,
            colorInHEX: "0xffff00",
            _this
          });

          _this.time.delayedCall(
            3000,
            destroyObjects,
            [objectBeingEaten, flashingObjectGraphics],
            _this
          );

          _this.time.delayedCall(
            3000,
            _pet => {
              _pet.setState(PET_STATES.IDLE);
              _pet.playCurrentStateAnimation();
            },
            [petEating],
            _this
          );
        }
      };

      /**
       * HELPER FUNCTIONS
       */
      /**
       * @function destroyObjects Useful helper to destroy all given objects
       */
      const destroyObjects = (...args) => {
        args.forEach(arg => arg.destroy());
      };

      /**
       * Create all game objects and their relationships here:
       * 1) Pet
       * 2) Input handling
       */
      function create() {
        setupTileBackground(BACKGROUNDS.PINK, this);
        defineAllAnimations(this);

        pet = createPet({ petConfigKey: PET_CONFIG_KEYS.ROCK, _this: this });
        pet.playCurrentStateAnimation();

        food = createFood({
          foodConfigKey: FOOD_CONFIG_KEYS.BANANAS,
          phaser: this
        });
        food.playCurrentStateAnimation();

        pointer = setupPointer(SPRITES.UI.POINTER.CLICK, this);

        // Collisions
        defineObjectInteractions(this);
        setupInputHandlers(this);
      }

      /**
       *  Handle all interactions here
       */
      function update() {}
    </script>
  </body>
</html>
