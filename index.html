<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
  </head>
  <body>
    <script>
      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
          default: "arcade",
          arcade: {
            debug: false
          }
        },
        scene: {
          preload: preload,
          create: create,
          update: update
        }
      };

      let pet = null;
      let cursor = null;
      const game = new Phaser.Game(config);

      const PET_STATES = {
        IDLE: "IDLE",
        MOVING: "MOVING"
      };

      // Asset constants
      const BACKGROUNDS = {
        PINK: "background-pink"
      };

      // Sprite constants
      const SPRITES = {
        PET: {
          ROCK: {
            IDLE: "sprite-rock-idle",
            MOVING: "sprite-rock-moving"
          }
        },
        UI: {
          POINTER: {
            CLICK: "sprite-pointer-click"
          }
        }
      };

      // Animation constants
      const ANIMATIONS = {
        PET: {
          ROCK: {
            IDLE: "animation-rock-idle",
            MOVING: "animation-rock-moving"
          }
        },
        UI: {
          POINTER: {
            CLICK: "animation-pointer-click"
          }
        }
      };

      /**
       * Load all assets here:
       * 1) Pet sprite
       */
      function preload() {
        this.load.image(BACKGROUNDS.PINK, "assets/backgrounds/pink.png");
        this.load.spritesheet(
          SPRITES.PET.ROCK.IDLE,
          "assets/pets/rock/idle.png",
          {
            frameWidth: 38,
            frameHeight: 34
          }
        );
        this.load.spritesheet(
          SPRITES.PET.ROCK.MOVING,
          "assets/pets/rock/moving.png",
          {
            frameWidth: 38,
            frameHeight: 34
          }
        );
        this.load.spritesheet(
          SPRITES.UI.POINTER.CLICK,
          "assets/ui/clicked.png",
          {
            frameWidth: 32,
            frameHeight: 32
          }
        );
      }

      /**
       * Create all game objects and their relationships here:
       * 1) Pet
       * 2) Input handling
       */
      function create() {
        /**
         * @function setupPet Initialize and return pet with sprite, physics and collision with world bounds.
         * Starts in the center of the canvas
         */
        const setupPet = spriteKey => {
          const newPet = this.physics.add.sprite(400, 300, spriteKey);
          newPet.setCollideWorldBounds(true);

          return newPet;
        };

        /**
         * @function setupCursor Initialize and return an invisible cursor with sprite, physics and animations. Initially placed in (0, 0) of the canvas.
         */
        const setupCursor = cursorSprite => {
          const newCursor = this.physics.add
            .sprite(0, 0, cursorSprite)
            .setVisible(false);

          newCursor.on("animationcomplete", () => {
            newCursor.setVisible(false);
          });

          return newCursor;
        };

        /**
         * @function setupBackground Build background given background tile sprite key.
         *
         * TODO: Actually build background from tile sprite
         */
        const setupBackground = backgroundTileSpriteKey => {
          this.add.image(400, 300, backgroundTileSpriteKey);
        };

        /**
         * @function defineAnimations Define all animations.
         *
         * Trying to keep things cons
         */
        const defineAnimations = () => {
          this.anims.create({
            key: ANIMATIONS.PET.ROCK.IDLE,
            frames: this.anims.generateFrameNumbers(SPRITES.PET.ROCK.IDLE, {
              start: 0,
              end: 14
            }),
            frameRate: 10,
            repeat: -1
          });
          this.anims.create({
            key: ANIMATIONS.PET.ROCK.MOVING,
            frames: this.anims.generateFrameNumbers(SPRITES.PET.ROCK.MOVING, {
              start: 0,
              end: 14
            }),
            frameRate: 15,
            repeat: -1
          });

          // Clicked animation
          this.anims.create({
            key: ANIMATIONS.UI.POINTER.CLICK,
            frames: this.anims.generateFrameNumbers(SPRITES.UI.POINTER.CLICK, {
              start: 0,
              end: 6
            }),
            frameRate: 15
          });
        };

        const setupInputHandlers = () => {
          // Move to mouse and
          this.input.on(
            "pointerdown",
            function(pointer) {
              cursor.setActive(true);
              cursor.anims.play(ANIMATIONS.UI.POINTER.CLICK);

              pet.state = PET_STATES.MOVING;
              cursor.setVisible(true).setPosition(pointer.x, pointer.y);

              this.physics.moveToObject(pet, pointer, 150);
            },
            this
          );
        };

        setupBackground(BACKGROUNDS.PINK);

        // The player and its settings
        pet = setupPet("sprite-rock-idle");

        cursor = setupCursor("sprite-clicked");

        // Collisions
        this.physics.add.overlap(
          pet,
          cursor,
          () => {
            pet.state = PET_STATES.IDLE;
            pet.setVelocity(0);
            cursor.setPosition(0, 0);
          },
          null,
          this
        );

        defineAnimations();

        setupInputHandlers();
      }

      /**
       *  Handle all interactions here
       */
      function update() {
        handlePetAnimation(pet);
      }

      /**
       * @function handlePetAnimation Apply pet's animation depending on their state.
       *
       * There should be an animation for each state.
       */
      handlePetAnimation = pet => {
        switch (pet.state) {
          case PET_STATES.MOVING:
            pet.anims.play(ANIMATIONS.PET.ROCK.MOVING, true);
            break;
          default:
            pet.anims.play(ANIMATIONS.PET.ROCK.IDLE, true);
        }
      };
    </script>
  </body>
</html>
